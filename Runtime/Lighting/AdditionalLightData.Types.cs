using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine.Serialization;

namespace UnityEngine.Rendering.Universal
{
    /// <summary>
    /// Unit of the lights supported in HDRP
    /// </summary>
    public enum LightUnit
    {
        /// <summary>Total power/flux emitted by the light.</summary>
        Lumen,
        /// <summary>Flux per steradian.</summary>
        Candela,    // lm/sr
        /// <summary>Flux per unit area.</summary>
        Lux,        // lm/m²
        /// <summary>Flux per unit area and per steradian.</summary>
        Nits,       // lm/m²/sr
        /// <summary>ISO 100 Exposure Value (https://en.wikipedia.org/wiki/Exposure_value).</summary>
        Ev100,
    }

    internal enum DirectionalLightUnit
    {
        Lux = LightUnit.Lux,
    }

    internal enum AreaLightUnit
    {
        Lumen = LightUnit.Lumen,
        Nits = LightUnit.Nits,
        Ev100 = LightUnit.Ev100,
    }

    internal enum PunctualLightUnit
    {
        Lumen = LightUnit.Lumen,
        Candela = LightUnit.Candela,
        Lux = LightUnit.Lux,
        Ev100 = LightUnit.Ev100
    }

    public partial class AdditionalLightData
    {
        [System.NonSerialized]
        static Dictionary<int, LightUnit[]> supportedLightTypeCache = new Dictionary<int, LightUnit[]>();

        /// <summary>
        /// The type of light used.
        /// This handle some internal conversion in Light component for culling purpose.
        /// </summary>
        public LightType type
        {
            get => legacyLight.type;
            set
            {
                if (type != value)
                {
                    switch (value)
                    {
                        case LightType.Directional:
                            legacyLight.type = LightType.Directional;
                            break;
                        case LightType.Spot:
                            legacyLight.type = LightType.Spot;
                            break;
                        case LightType.Point:
                            legacyLight.type = LightType.Point;
                            break;
                        case LightType.Area:
                            legacyLight.type = LightType.Area; // default is Rectangle type, Disc type can be changed via light shape
                            break;
                        default:
                            Debug.Assert(false, $"Unknown {typeof(LightType).Name} {value}.");
                            break;
                    }

                    // If the current light unit is not supported by the new light type, we change it
                    var supportedUnits = GetSupportedLightUnits(value);
                    if (!supportedUnits.Any(u => u == lightUnit))
                        lightUnit = supportedUnits.First();
                    UpdateAllLightValues();
                }
            }
        }
        
        string GetLightTypeName()
        {
            if (legacyLight.type == LightType.Area)
                return $"{legacyLight.type}AreaLight";
            else
            {
                if (legacyLight.type == LightType.Spot)
                    return $"{legacyLight.type}SpotLight";
                else
                    return $"{legacyLight.type}Light";
            }
        }
        
        /// <summary>
        /// Give the supported lights unit for the given parameters
        /// </summary>
        /// <param name="type">The type of the light</param>
        /// <param name="spotLightShape">the shape of the spot.You can put anything in case it is not a spot light.</param>
        /// <returns>Array of supported units</returns>
        public static LightUnit[] GetSupportedLightUnits(LightType type)
        {
            LightUnit[] supportedTypes;

            // Combine the two light types to access the dictionary
            int cacheKey = ((int)type & 0xFF) << 0;
            cacheKey |= ((int)LightType.Spot & 0xFF) << 8;

            // We cache the result once they are computed, it avoid garbage generated by Enum.GetValues and Linq.
            if (supportedLightTypeCache.TryGetValue(cacheKey, out supportedTypes))
                return supportedTypes;

            if (type == LightType.Area)
                supportedTypes = Enum.GetValues(typeof(AreaLightUnit)).Cast<LightUnit>().ToArray();
            else if (type == LightType.Directional)// || (type == LightType.Spot && spotLightShape == SpotLightShape.Box))
                supportedTypes = Enum.GetValues(typeof(DirectionalLightUnit)).Cast<LightUnit>().ToArray();
            else
                supportedTypes = Enum.GetValues(typeof(PunctualLightUnit)).Cast<LightUnit>().ToArray();

            supportedLightTypeCache[cacheKey] = supportedTypes;

            return supportedTypes;
        }

        /// <summary>
        /// Check if the given type is supported by this type and shape.
        /// </summary>
        /// <param name="type">The type of the light</param>
        /// <param name="spotLightShape">the shape of the spot.You can put anything in case it is not a spot light.</param>
        /// <param name="unit">The unit to check</param>
        /// <returns>True: this unit is supported</returns>
        public static bool IsValidLightUnitForType(LightType type, LightUnit unit)
        {
            LightUnit[] allowedUnits = GetSupportedLightUnits(type);

            return allowedUnits.Any(u => u == unit);
        }

    }
}
